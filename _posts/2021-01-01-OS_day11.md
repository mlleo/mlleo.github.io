---
title: "[OS] Operating System Concepts CH 6-1"
categories: 
  - CS
last_modified_at: 2021-01-01 12:00:00
comments: true
use_math: true # MathJax On
---

#### Synchronization Background
- Processes can execute concurrently
- Concurrent access to shared data may result in ***data inconsistency*** (ex.multi-threads in a process OR multi-processes with shared memory)
- Maintaining data consistency requires mechanisms to ***ensure the orderly execution*** of cooperating processes

![sync](https://user-images.githubusercontent.com/62474292/112114696-b2ef2000-8bfb-11eb-86b5-1e8ebb445f85.JPG)

#### Synchronization Problem
- Two or more concurrent threads(or processes) accessing and manipulating a shared resource create a ***race condition***
- Race condition may lead to non-deterministic results
- OS is full of such a shared resource
- The output of the program is not deterministic, it varies from run to run even with same inputs, depending on timing
- Hard to debug... ("Heisenbugs...")

#### Critical Section
- A critical section is a piece of code that accesses a shared resource

![critical_Section](https://user-images.githubusercontent.com/62474292/112116902-17ab7a00-8bfe-11eb-8cc3-536cc8a7373e.JPG)

- Need mutual exclusion for correct execution with critical sections
  - Execute the critical section atomically (all or nothing)
  - Only one thread at a time can execute in the critical section
  - All other threads are forced to wait on entry
  - When a thread leaves a critical section, another can enter

#### Locks
- An object (in memory) that provides mutual exclusion with the following two operations:
  - acquire() : wait until lock is free, then grab it
  - release() : unlock and wake up any thread waiting in acquire()
- Using locks
  - Lock is initially free
  - Call acquire() before entering a critical section, and release() after leaving it
  - acquire() does not return until the caller holds the lock
  - On acquire(), a thread can spin(spinlock) or block(mutex)
  - At most one thread can hold a lock at a time

![cri](https://user-images.githubusercontent.com/62474292/112117411-b041fa00-8bfe-11eb-9924-509271e97d83.JPG)

#### Requirements for Locks
- Correctness
  - Mutual exclusion : only one thread in critical section at a time
  - Progress : if several threads want to enter the same critical section, one must be allowed to proceed
  - Bounded waiting : starvation-free, must eventually allow each waiting thread to enter
- Fairness
  - Each thread gets a fair chance at acquiring the lock
- Performance
  - Time overhead for a lock

#### Initial implementation of Spinlock
 
![spinlock](https://user-images.githubusercontent.com/62474292/112119619-e1bbc500-8c00-11eb-98df-dad4c0fc9631.JPG)

- mutual exclusion problem!

#### Implementing Locks
- Software-only algorithms
  - Dekker's algorithm (1962)
  - ***Peterson's algorithm*** (1981)
  - Lamport's Bakery algorithm for more than two tasks (1974)
- Hardware atomic instructions
  - Disable interrupts
  - Hardware atomic instructions
 
#### Second attempt to implement spinlock

![spinlock2](https://user-images.githubusercontent.com/62474292/112126415-c7391a00-8c07-11eb-8c67-ff28ca350eda.JPG)

- progress problem!

#### Peterson's algorithm
- solves the critical section problem for two tasks

![peterson](https://user-images.githubusercontent.com/62474292/112127743-19c70600-8c09-11eb-8652-188dc1279e5c.JPG)

- Mutual exclusion : Only one thread in critical section at a time
- Progress : One will enter the critical section right after the other releases
- Bounded waiting : Eventually allow each waiting thread to enter


