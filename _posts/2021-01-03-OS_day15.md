---
title: "[OS] Memory Management 1"
categories: 
  - CS
tags:
  - Operating System
last_modified_at: 2021-01-03 12:00:00
comments: true
use_math: true # MathJax On
---

Memory Management Part 1

#### Background
- Program must be brought (from disk) into memory and placed within a process for it to be run (Von Neumann architecture)
- Main memory and registers are the only storage that CPU can access directly
- Cache sits between main memory and CPU registers
- Each process needs its own address space, but memory is an expensive system resource so we should manage memory efficiently

#### Address
- A location in the memory
- Physical address vs. Logical address
- Absolute address vs. Relative address

#### Address in computers
- Physical address (PA) : address seen by the memory unit
- Logical address (LA) : address generated by the CPU
- CPU sees logical addresses
- Memory Management Unit (MMU) translates LAs to PAs

![memory](https://user-images.githubusercontent.com/62474292/112439716-cf6e9200-8d8c-11eb-8087-51ea0310358d.JPG)

- How can MMU map logical addresses to physical addresses?

#### Base and Limit Registers
- A pair of base and limit registers define the logical address space that a process can access
- CPU must check every memory access generated in user mode to be sure that it is between base and limit for that user (Hardware Address Protection)

![1](https://user-images.githubusercontent.com/62474292/112460168-f2577100-8da1-11eb-95c4-5c6fed286da6.JPG)
![2](https://user-images.githubusercontent.com/62474292/112460277-0f8c3f80-8da2-11eb-98f0-f2b7b9710977.JPG)

#### Address Binding
- Address binding of instructions and data to memory addresses can happen at three different stages

![1](https://user-images.githubusercontent.com/62474292/112565745-fd051b00-8e20-11eb-9e3d-f17a39237c6a.JPG)

  - Compile time: If memory location known a priori, absolute code(= code that loads at a known, fixed memory address) can be generated (must recompile code if starting location changes)
    ![compile](https://user-images.githubusercontent.com/62474292/112566014-8e748d00-8e21-11eb-8606-7f87ac3c6841.JPG)
    - logical address = physical address
    - Can load process fast, but collision can be occurred if generated address space is used by other process
    - No more used in multi-programming operating system
  - Load time: Must generate relocatable code(= machine language that can be run from any memory location) if memory location is not known at compile time
    - If compiler cannot decide the physical address, it change symbolic address to relocatable address

#### Fixed Partitions
- Break up physical memory into same-sized partitions
  - Physical address = base address + logical address(virtual address/relative address)
  - cannot access beyond its partition
  - the number of partitions = degree of multiprogramming
- Put a base register in MMU
- Then, OS loads the base register when it switches processes
- Check whether logical address >= parition size (not eligible)

![3](https://user-images.githubusercontent.com/62474292/112476187-fd67cc80-8db4-11eb-9168-b1a22f69c1e8.JPG)
![2](https://user-images.githubusercontent.com/62474292/112440926-39d40200-8d8e-11eb-8d63-1b3c2b31a059.JPG)
![3](https://user-images.githubusercontent.com/62474292/112440927-39d40200-8d8e-11eb-9d55-6b3f6f19c20a.JPG)

Advantage
- Easy to implement
- Fast context switch (just save/restire the base register on context switch)
Problem
- Partition size : One size does not fit all
- Internal fragmentation
  - A resource allocated to an instance cannot be utilized by other instances even though a part of the resource is not being used
  - Memory is internally fragmented by the fixed partitioning

![4](https://user-images.githubusercontent.com/62474292/112441517-9afbd580-8d8e-11eb-8779-e39aa9c04239.JPG)

#### Variable Partitions
- Improve the fixed partitioning
  - allow variable partition sizes
  - assume OS knows the memory size that processes need in advance
  - allocate a contiguous chunk from holes
- Should check the access limit considering the allocated memory size
- No internal fragmentation

![1](https://user-images.githubusercontent.com/62474292/112443077-dc40b500-8d8f-11eb-8288-884d7b052a4c.JPG)
![2](https://user-images.githubusercontent.com/62474292/112443081-dd71e200-8d8f-11eb-8110-abb80c6bb398.JPG)

Problems : External fragmentation
- As OS load and unload processes, holes are left scattered throughout physical memory
- Become unable to allocate a contiguous chunk even though the sum of holes is greater than the required chunk

![3](https://user-images.githubusercontent.com/62474292/112443306-23c74100-8d90-11eb-9e5f-fa4ee816ffe4.JPG)

Solutions
- Contiguous : compaction
- Non-contiguous : paging and segmentation

![4](https://user-images.githubusercontent.com/62474292/112447454-af42d100-8d94-11eb-990a-bcb632deca86.JPG)

Allocation strategies

![5](https://user-images.githubusercontent.com/62474292/112447462-b073fe00-8d94-11eb-9497-0bdc5108b92f.JPG)

- First fit : Allocate from the first hole that is big enough
  - 50% of the size of the allocated memory is lost to external fragmentation when the first-fit policy is used
- Best fit : Allocate from the smallest hole that is big enough
  - make small fraction of memory which cause external fragmentation
- Worst fit : Allocate from the largest hole

